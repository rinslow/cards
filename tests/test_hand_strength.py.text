# Testing internal implementation of HandEvaluator
def test_22333():
    hand = EvalutedHand(Hand(
        Card(rank=2, suit=Suits.HEARTS),
        Card(rank=2, suit=Suits.HEARTS),
        Card(rank=3, suit=Suits.SPADES),
        Card(rank=3, suit=Suits.CLUBS),
        Card(rank=3, suit=Suits.DIAMONDS),
    ))

    # Even more convenient: 
    # hand = EvaluatedHand(Hand.from_str("2h2h3s3c3d"))

    assert hand.strength == HandStrength.FullHouse
    assert hand.kickers == [3, 3, 2, 2, 2]


# Functional Testing
def test_22233_vs_22333():
    hand1 = EvaluatedHand.from_str("2♥️2♥️3♠️3♣️3♦️")  # Static constructor (syntactic sugar shortcut)
    hand2 = EvaluatedHand.from_str("2h2h2s3c3d")

    assert hand1.beats(hand2)
    # asssert hand1 > hand2
    # OR, without magic methods:
    # assert hand1.stronger_than(hand2)


def test_12345_vs_45678():
    hand1 = EvaluatedHand(Hand.parse("2♥2♥3♠ 3♣ 3♦"))
    hand2 = EvaluatedHand.parse("4♥ 5♥ 6♠ 7♣ 8♦")   # Zain shli, its comfortable then its not stupid

    assert hand2.beats(hand1)


class Hand:
    # ...
    def beats(self, other_hand):
        return self.strength > other_hand.strength


# Optionally, you can also use comparison MAGIC METHODS: 
# You need ONE of these methods:
# __le__   :  less than or equal <=
# __ge__   :  greater than or equal  >=  

# Not enough:
#  __eq__  :   equal   ==
# __ne__   :   not equal !=
#  __lt__  :  less than  < 
# __gt__   :  greater than >


A LE B, B LE A : EQUAL
A LE B NOT B LE A : A < B

B LE A NOT A LE B : A > B
B LE A A LE B : EQUAL


def calculate_book_name(name):
    import  time; time.sleep(10) # Takes 10 seconds!
    return name

# __iter__ method

class Bookshelf:
    def __iter__(self):
        yield from ["book a", "book b", "book c", calculate_book_name("fdsafadsafdsa")]

for book in Bookshelf():
    print(book)



# iter -> returns Iterator
# class that has next() method
# next returns item or throws StopIteration


class BookIterator:
    def __init__(self):
        self.current_pointer_index = 0
        self.array = ["book a", "book b", "book c"]

    def __next__(self):
        if self.current_pointer_index == 3:
            raise StopIteration
        self.current_pointer_index += 1
        return self.array[self.current_pointer_index]

for book in BookIterator():
    print(book)

# Same as:
while True:
    try:
        print(next(BookIterator()))
    except StopIteration:  # in python exceptions are cheap, not true in C#
        break


